#include <stdlib.h>
#include <stdint.h>
#include "HardestGame/game.h"
#include "HardestGame/config.h"

#include "drivers/keyboard.h"
#include "drivers/vga.h"

#include "util/ublaze_util.h"
#include "game_view/game_view.h"

/** To prevent blinking */
#pragma pack
typedef struct {
	uint16_t id;
	uint8_t x;
	uint8_t y;
}moveable_game_element_t;

moveable_game_element_t *get_moveable_elements(struct map_field_t **map, const int map_x, const int map_y,int *num) {

	moveable_game_element_t moveable_elements[40]; // magic number, some buffer size must be spiecified
	int moveable_elements_ctr = 0;

	for(uint16_t y=0; y<map_y; y++){
		for(uint16_t x=0; x<map_x; x++){
			if((map[x][y].type == PLAYER) || (map[x][y].type == TRAP))
				moveable_elements[moveable_elements_ctr].id = map[x][y].id;
				moveable_elements[moveable_elements_ctr].x = x;
				moveable_elements[moveable_elements_ctr].y = y;
				moveable_elements_ctr++;
		}
	}

	moveable_game_element_t *ret = malloc(sizeof(moveable_game_element_t) * moveable_elements_ctr);
	while(moveable_elements_ctr--> 0) {
		ret[moveable_elements_ctr] = moveable_elements[moveable_elements_ctr];
	}
	return ret;
}

int main() {
	static struct game_t *game = (struct game_t*)0xDEAD;
	struct map_field_t **map = NULL;
	int map_x=0, map_y=0;
	enum player_move_t player_move = NONE;
	moveable_game_element_t *moveable_elements = NULL;
	int moveable_ctr = 0;

	game = game_make();
	game->init(game);
	game->update(game, NONE);
	map = game->get_map(game, &map_x, &map_y);
//	moveable_elements = get_moveable_elements(map, map_x, map_y,&moveable_ctr);
	game->update(game, NONE);

	while(1){
		vga_clean();
		game_view_draw(map, map_x, map_y);
		ublaze_delay(50);

		if(keyboard_get_state().key_state == PRESSED) {
			switch(keyboard_get_state().key){
				case KEY_W:
					player_move = UP;
					break;
				case KEY_S:
					player_move = DOWN;
					break;
				case KEY_A:
					player_move = LEFT;
					break;
				case KEY_D:
					player_move = RIGHT;
					break;
				default:
					player_move = NONE;
					break;
			}
		} else {
			player_move = NONE;
		}

		switch(game->get_state(game)) {
		case RUNNING:
			break;
		case GAME_OVER:
			game->reset(game);
		case LEVEL_CHANGED:
			game->update(game, NONE);
			map = game->get_map(game, &map_x, &map_y);
			break;
		default:
			break;
		}

		game->update(game, player_move);
		ublaze_delay(100);
	}
}




